/******************************************************************************\
FILE:           std_pause_page.zm
AUTHOR:         Theo Veenker <theo.veenker@beexy.nl>
ADAPTED BY:     -

DESCRIPTION:

Provides a page object for displaying messages. It consists of a message area
and an OK button.


HISTORY:
2009-12-02 TV   Created as part of the standard Zep modules.

\******************************************************************************/


Page audio_instruction_page
{
    bool        allowed_to_continue;      // if set, continue keys enabled


    init()
    {
        fill_pattern_color = INFO_PAGE_COLOR;
    }


    on_event:key_press()
    {
        if (input_key == KEY_Escape)
            done(CONTINUE);
        else if (target != null && allowed_to_continue &&
                (input_key == KEY_Return || input_key == ' '))
            done(CONTINUE);
        else
            handle_special_key(this, input_key, input_modifiers);
    }


    CanvasGadget feedback
    {
        init()
        {
            fill_pattern_color = color:none;
            size = 0,0;
        }

        void update()
        {
            //feedback.offset_y = feedback.actual_height;
            image1.offset_y = -image1.image_height;
            image1.y = test_window1.height-(test_page_overlay.main.bottom_margin + test_page_overlay.main.top_margin);
        }

        ImageShape image1 {
            init()
            {
                is_visible = true;
                image = stimuli_dir() + "images/" + "owl_speaker_icon.svg";
            }
        }
    }

    on_event:message()
    {
        // Handle 'continue' message received from control page.
        if (message_arg == CONTINUE && allowed_to_continue)
            done(CONTINUE);
    }



    SoundChain instruction
    {
        // Sound source/producer object.
        SoundFile clip {}


        // Sound sink/consumer object.
        SoundPlayback playback {}


        void play(time t)
        {
            abort();

            playback.device = sound_output_device;

            start(t);
        }

        on_event:finish()
        {
            allowed_to_continue = true;
        }
    }


    Timer timer
    {
        on_event:expire()
        {
            done(TIMEOUT);
        }
    }


    void done(int msgid)
    {
        timer.abort();
        instruction.abort();

        allowed_to_continue = false;

        signal_target(msgid);   // Tell caller we're done.
        target = null;

        if (control.target == this)
        {
            control.disable_keys();
            control.button_box.disable_buttons();
            control.target = null;
        }
    }


    //==========================================================================
    void setup(string sound_filename)
    {
        instruction.clip.file = stimuli_dir() + "sounds/" + sound_filename;
        feedback.update();
    }

    void action(Object caller, dur timeout=0s,
        dur showdelay=-1s, dur fadedur=-1s, bool kbd=false)
    {
        timer.abort();

        // Force page show delay and transition duration in sane range.
        if (showdelay < 0s) showdelay = PAGE_TRANSITION_DELAY;
        else showdelay = limit(showdelay, 0s, MAX_PAGE_TRANSITION_DELAY);
        if (fadedur < 0s) fadedur = PAGE_TRANSITION_DURATION;
        else fadedur = limit(fadedur, 0s, MAX_PAGE_TRANSITION_DURATION);

    	// Clear page transition delay.
    	page_transition_delay = 0s;

        // Let's delay the first test page trial following this page.
        first_trial_delay = FIRST_TRIAL_EXTRA_DELAY;

        if ( test_window1.show_page(this, now() + showdelay, fadedur) == 0 )
        {
            // Page not yet shown. Extend timeout period (if applicable)
            // until page is fully visible (fade-in has finished).
            if (timeout > 0s)
                timeout += expected_transition_finish_time - now();
        }

        // Play the instruction
        instruction.play(expected_transition_finish_time+DEFAULT_AUDIO_INSTRUCTION_DELAY);

        if (caller != null)
        {
            allowed_to_continue = kbd && !test_window1.is_output_only();

            if (timeout > 0s) timer.start(now() + timeout);

            target = caller;
            control.target = this;
            control.disable_keys();
            control.enable_key(KEY_Return, CONTINUE);
            control.enable_key(' ', CONTINUE);
            control.target = this;
            control.button_box.disable_buttons();
            control.button_box.enable_all_buttons(1);

            if (!test_window1.is_output_only())
                test_window1.activate();
            else if (test_window1.is_output_only())
                ctrl_window.activate();
        }
        else
        {
            allowed_to_continue = false;
            target = null;
        }
    }


    void stop_action()
    {
        timer.abort();
        instruction.abort();

        allowed_to_continue = false;

        target = null;

        if (control.target == this)
        {
            control.disable_keys();
            control.target = null;
        }
    }
}
